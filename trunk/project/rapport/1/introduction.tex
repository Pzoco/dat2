\pagestyle{fancy}
\lhead{}
\chead{}
\cfoot{}
\fancyfoot[RO,LE]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}
Designing a programming language is a task that is not too easily undertaken, not only is the implementation quite a unique process, however decision making is critical in order to create a properly functioning and well-rounded language. Today, many major implementations of multi-paradigm languages exist, which are all extremely thoroughly developed and is in widespread use in the world. Extensions and libraries for major language implementations make them extremely powerful tools, along with the support of the users of that. Reigning supreme is the ever so popular \textit{C} and Java, due to their widespread use an excellent compatibility. But not all languages are necessarily designed with the purpose, sometimes it might be practical to implement a minor language, or maybe even a major one for a specific purpose. In computer science having the right tools at hand is crucial, and if the tools are not available, you will have to develop them yourself. \\
A purpose for such a specific language is in this case a scripting language for a simulation. Such a specific language will have to be tailored to very specific needs of the simulation in question
Similar applications of scripting languages such as this do exist, as contests are held within robotics students to see who can develop the best behaviour of a machine. Developing the best script to defeat an opponent, which may or may not be dependant on the script your opponent has set forth is an interesting approach to see how basic dynamic state-handling can govern a unit and imitate intelligent behaviour.


\section{Purpose}
% Purpose sektionen er en fortsættelse af introduction der fortæller kort hvad meningen er med projektet, som så leder over i den mere præcise og korte definition i problem statement %
The purpose of the language in itself is not to do anything revolutionary in regards of language design, but rather to plug in to a hosting application. The script will then alter the flow of the hosting application entirely dependant upon the script set down by a programmer.
To provide a meaningful context for this language implementation we would create a simulation 'game'. 
Strategy games are a very popular popular genre within the modern game-industry\cite{strat}. In strategy games, your victory or defeat depends primarily on the applied tactics. However, most modern strategy games leave room for error through inferior control or attention on the battlefield. The purpose of our language is to define your tactics in advance and have the game play out as predicted by the best abilities of the scripters. As such the main and overall purpose is the implementation of a minor language.

\section{Problem Statement}
During the course of this project our goals were to:

\begin{itemize}
\item Apply concepts of programming language design
\item Determine important design choices and argument for these choices
\item Provide a meaningful context for an implementation of a simple language
\item Implement our own interpreter or compiler
\item Build a running simulator
\end{itemize}


\subsection{Outline of the report}
In the following, we give an overview of the structure of the report.

\begin{itemize}

\item \textbf{Chapter 2} describes the problem domain, \\ 
a script-able game that simulates warfare. Two or more competing armies are fighting in a simulated world.\\
In this Chapter we describe the game in details, giving an internal semantics to the possible actions and states(situations) that can occur during the game.
\item \textbf{Chapter 3} presents our high level design choices with respect to   the language that constitutes the 'core' of our system. 
\item \textbf{Chapter 4} presents the language in detail from the point of view of a programmer that needs to program a regiment for our system. The specification of the language, is presented, documenting the principle elements of the language.

%5. The actual design of the language, BNF, EBNF, Contextual analysis.
\item \textbf{Chapter 5} describes the actual design of the language \textit{WAR} representing it in a formal way with the known Backus-Naur Form, and later the Extended Backus-Naur Form. This chapter also represents how the scope-rules and type-rules of the language works.

%6. Implementation (Description of how we implemented it) - Visitor pattern (Page 320, Brown). - Why we chose C# (Maybe tombstone)
\item \textbf{Chapter 6} this chapter is about the implementation of all the different parts of the language. It describes in details how the 4 parts; scanner, parser, contextual analyzer and the interpretation are implemented.

%7. Usecases - (Example of the game (scripts, configs, screenshots etc.))
\item \textbf{Chapter 7} this chapter is about tests of the simulator. Scripts for the simulator and screenshots from the simulator are shown here.

%8. How to expand - (What we would have done if we had infinite time)
\item \textbf{Chapter 8} this chapter represents the ideas that haven't been made, but could have been fulfilled in later projects.

%9. Conclusion - Dicussion
\item \textbf{Chapter 9} this part is a conclusion and discussion part, where we discuss what went good, and what went wrong. This is also where we conclude on the problems we might have experienced.





\end{itemize}


